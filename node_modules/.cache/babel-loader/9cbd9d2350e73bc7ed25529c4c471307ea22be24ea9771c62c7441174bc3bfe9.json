{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"animation-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_smolitux_canvas = _resolveComponent(\"smolitux-canvas\");\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createVNode(_component_smolitux_canvas, {\n    ref: \"canvas\",\n    onMouseWheel: $options.onMouseWheel,\n    onMouseDown: $options.onMouseDown,\n    onMouseUp: $options.onMouseUp,\n    onMouseMove: $options.onMouseMove,\n    onMouseClick: $options.onMouseClick,\n    onDoubleClick: $options.onDoubleClick\n  }, null, 8 /* PROPS */, [\"onMouseWheel\", \"onMouseDown\", \"onMouseUp\", \"onMouseMove\", \"onMouseClick\", \"onDoubleClick\"])]);\n}","map":{"version":3,"names":["class","_createElementBlock","_hoisted_1","_createVNode","_component_smolitux_canvas","ref","onMouseWheel","$options","onMouseDown","onMouseUp","onMouseMove","onMouseClick","onDoubleClick"],"sources":["/workspace/Smolitux-Suite/src/components/Smolitux/Canvas/Animation.vue"],"sourcesContent":["<template>\n  <div class=\"animation-container\">\n    <smolitux-canvas\n      ref=\"canvas\"\n      @mouse-wheel=\"onMouseWheel\"\n      @mouse-down=\"onMouseDown\"\n      @mouse-up=\"onMouseUp\"\n      @mouse-move=\"onMouseMove\"\n      @mouse-click=\"onMouseClick\"\n      @double-click=\"onDoubleClick\"\n    />\n  </div>\n</template>\n\n<script>\nimport { mapState, mapActions } from 'vuex'\nimport SmolituxCanvas from './Canvas.vue'\n\nexport default {\n  name: 'SmolituxAnimation',\n  components: {\n    SmolituxCanvas\n  },\n  data() {\n    return {\n      isRunning: false,\n      animationLoop: null,\n      fps: 30,\n      draggedNode: null,\n      scale: 1,\n      offset: { x: 0, y: 0 }\n    }\n  },\n  computed: {\n    ...mapState('network', ['nodes', 'connections', 'selectedNode'])\n  },\n  mounted() {\n    this.start()\n    this.connect()\n  },\n  beforeDestroy() {\n    this.stop()\n    this.disconnect()\n  },\n  methods: {\n    ...mapActions('network', [\n      'connect',\n      'disconnect',\n      'addNode',\n      'updateNode',\n      'removeNode',\n      'addConnection',\n      'removeConnection',\n      'selectNode'\n    ]),\n    start() {\n      if (this.isRunning) return\n      this.isRunning = true\n      this.animationLoop = setInterval(this.draw, 1000 / this.fps)\n    },\n    stop() {\n      if (!this.isRunning) return\n      this.isRunning = false\n      if (this.animationLoop) {\n        clearInterval(this.animationLoop)\n        this.animationLoop = null\n      }\n    },\n    draw() {\n      const canvas = this.$refs.canvas\n      if (!canvas) return\n\n      const ctx = canvas.$refs.canvas.getContext('2d')\n      ctx.clearRect(0, 0, canvas.$refs.canvas.width, canvas.$refs.canvas.height)\n\n      // Apply transformations\n      ctx.save()\n      ctx.translate(this.offset.x, this.offset.y)\n      ctx.scale(this.scale, this.scale)\n\n      // Draw connections\n      this.connections.forEach(connection => {\n        this.drawConnection(ctx, connection)\n      })\n\n      // Draw nodes\n      this.nodes.forEach(node => {\n        this.drawNode(ctx, node)\n      })\n\n      ctx.restore()\n    },\n    drawNode(ctx, node) {\n      const radius = node.radius || 20\n      ctx.beginPath()\n      ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI)\n      \n      // Different colors for different node types\n      switch (node.type) {\n        case 'chatbot':\n          ctx.fillStyle = '#42b983'\n          break\n        case 'llm':\n          ctx.fillStyle = '#3498db'\n          break\n        case 'database':\n          ctx.fillStyle = '#e74c3c'\n          break\n        default:\n          ctx.fillStyle = '#95a5a6'\n      }\n\n      // Highlight selected node\n      if (this.selectedNode && this.selectedNode.id === node.id) {\n        ctx.lineWidth = 3\n        ctx.strokeStyle = '#f1c40f'\n      } else {\n        ctx.lineWidth = 1\n        ctx.strokeStyle = '#2c3e50'\n      }\n\n      ctx.fill()\n      ctx.stroke()\n\n      if (node.label) {\n        ctx.fillStyle = '#2c3e50'\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'middle'\n        ctx.font = '12px Arial'\n        ctx.fillText(node.label, node.x, node.y)\n      }\n\n      // Draw status indicator\n      const statusColors = {\n        active: '#2ecc71',\n        inactive: '#95a5a6',\n        error: '#e74c3c'\n      }\n      if (node.status && statusColors[node.status]) {\n        ctx.beginPath()\n        ctx.arc(node.x + radius - 5, node.y - radius + 5, 5, 0, 2 * Math.PI)\n        ctx.fillStyle = statusColors[node.status]\n        ctx.fill()\n      }\n    },\n    drawConnection(ctx, connection) {\n      const fromNode = this.nodes.find(n => n.id === connection.from.id)\n      const toNode = this.nodes.find(n => n.id === connection.to.id)\n      if (!fromNode || !toNode) return\n\n      ctx.beginPath()\n      ctx.moveTo(fromNode.x, fromNode.y)\n      ctx.lineTo(toNode.x, toNode.y)\n      ctx.strokeStyle = connection.color || '#95a5a6'\n      ctx.lineWidth = 2\n      ctx.stroke()\n\n      // Draw arrow\n      const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x)\n      const radius = toNode.radius || 20\n      const arrowLength = 15\n      const arrowWidth = 8\n\n      const endX = toNode.x - (radius * Math.cos(angle))\n      const endY = toNode.y - (radius * Math.sin(angle))\n\n      ctx.beginPath()\n      ctx.moveTo(endX, endY)\n      ctx.lineTo(\n        endX - arrowLength * Math.cos(angle - Math.PI/6),\n        endY - arrowLength * Math.sin(angle - Math.PI/6)\n      )\n      ctx.lineTo(\n        endX - arrowLength * Math.cos(angle + Math.PI/6),\n        endY - arrowLength * Math.sin(angle + Math.PI/6)\n      )\n      ctx.closePath()\n      ctx.fillStyle = connection.color || '#95a5a6'\n      ctx.fill()\n    },\n    onMouseWheel(event) {\n      event.preventDefault()\n      const delta = event.deltaY > 0 ? 0.9 : 1.1\n      this.scale *= delta\n    },\n    onMouseDown(event) {\n      const canvas = this.$refs.canvas.$refs.canvas\n      const rect = canvas.getBoundingClientRect()\n      const x = (event.clientX - rect.left - this.offset.x) / this.scale\n      const y = (event.clientY - rect.top - this.offset.y) / this.scale\n\n      // Check if clicked on a node\n      const clickedNode = this.nodes.find(node => {\n        const dx = node.x - x\n        const dy = node.y - y\n        return Math.sqrt(dx * dx + dy * dy) < (node.radius || 20)\n      })\n\n      if (clickedNode) {\n        this.draggedNode = clickedNode\n        this.selectNode(clickedNode)\n      } else {\n        // Start panning\n        this.draggedNode = null\n        this.selectNode(null)\n        canvas.style.cursor = 'grabbing'\n      }\n    },\n    onMouseUp(event) {\n      this.draggedNode = null\n      this.$refs.canvas.$refs.canvas.style.cursor = 'default'\n    },\n    onMouseMove(event) {\n      if (!this.draggedNode) return\n\n      const movementX = event.movementX / this.scale\n      const movementY = event.movementY / this.scale\n\n      this.updateNode({\n        id: this.draggedNode.id,\n        updates: {\n          x: this.draggedNode.x + movementX,\n          y: this.draggedNode.y + movementY\n        }\n      })\n    },\n    onMouseClick(event) {\n      // Handled in onMouseDown for better UX\n    },\n    onDoubleClick(event) {\n      if (this.selectedNode) {\n        // Open configuration panel (handled by parent)\n        this.$emit('configure-node', this.selectedNode)\n      } else {\n        // Create new node at click position\n        const canvas = this.$refs.canvas.$refs.canvas\n        const rect = canvas.getBoundingClientRect()\n        const x = (event.clientX - rect.left - this.offset.x) / this.scale\n        const y = (event.clientY - rect.top - this.offset.y) / this.scale\n\n        this.addNode({\n          id: Date.now(),\n          label: 'New Node',\n          type: 'chatbot',\n          x,\n          y,\n          status: 'inactive'\n        })\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.animation-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n</style>\n\n"],"mappings":";;EACOA,KAAK,EAAC;AAAqB;;;uBAAhCC,mBAAA,CAUM,OAVNC,UAUM,GATJC,YAAA,CAQEC,0BAAA;IAPAC,GAAG,EAAC,QAAQ;IACXC,YAAW,EAAEC,QAAA,CAAAD,YAAY;IACzBE,WAAU,EAAED,QAAA,CAAAC,WAAW;IACvBC,SAAQ,EAAEF,QAAA,CAAAE,SAAS;IACnBC,WAAU,EAAEH,QAAA,CAAAG,WAAW;IACvBC,YAAW,EAAEJ,QAAA,CAAAI,YAAY;IACzBC,aAAY,EAAEL,QAAA,CAAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}